# MBatch Copyright (c) 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 University of Texas MD Anderson Cancer Center
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# MD Anderson Cancer Center Bioinformatics on GitHub <https://github.com/MD-Anderson-Bioinformatics>
# MD Anderson Cancer Center Bioinformatics at MDA <https://www.mdanderson.org/research/departments-labs-institutes/departments-divisions/bioinformatics-and-computational-biology.html>

##  EBNplus Class
##  This class is for Emperical Bayes+limma+permutation adjustment of two datasets with replicates
##  This versiton the EBNplus will inherit some features and methods from EBNPdataClass like getBiComOrder
##  Author: Shiyun Ling, Rehan Akabani

#DF1batch ="character",  # The type of batch 1, it will be add to the end of sample name to distinguish the replicates with same sample name in two batches
#DF2batch ="character",  # The type of batch 2, it will be add to the end of sample name to distinguish the replicates with same sample name in two batches
#mat1Train="matrix",  # store the original training set of batch 1, it is generated by getValidationSet or divideSet
#mat2Train="matrix", # store the original training set of batch 2, it is generated by getValidationSet or divideSet
#mat1Test="matrix", # store the original test set of batch 1, it is generated by getTestSet or divideSet
#mat2Test="matrix", # store the original test set of batch 2, it is generated by getTestSet or divideSet
#mat1Validation = "matrix", # store the original validation set of batch 1, it is generated by getValidationSet or divideSet
#mat2Validation = "matrix", # store the original validation set of batch 2, it is generated by getValidationSet or divideSet
#batchWith0 = "character", # indicates the batch whose original data has left censoring value 0,  it could be “1”, “2”, “both”
#correct0 = "logical", # indicates whether in the adjustment, we need to correct the data whose original value is 0.  Now it could be TRUE or FALSE
#fixSet = "numeric",  #  which batch should be fixed in the adjustment. Now it could be 1, 2 or as.numeric(NA)  which means don’t fix any dataset
#useRep = "logical",  # indicates whether we want to use replicates.  It could be TRUE and FALSE.
#data4EB = "matrix",  # the data merged together for EB adjustment.  It is generated by getData4EB and called by EB.
#sampBatch = "data.frame",  # store the sample and Batch information, it is called by EB
#parList="list",   # return a list of parameters trained by EBNplus algorithm, it is generated by EB.
#trainEB ="matrix",  # store the EB adjusted training set, it is generated by EBadj.  When use EBadj, user can select which set he want to adjust: “train”, “test”, “valid”, “com” (means the whole replicate set) or “whole” which means whole set. Also apply to following relative slots.
#testEB = "matrix",  # store the EB adjusted test set
#comEB = "matrix", # store the EB adjusted replicates set
#validationEB = "matrix", # store the EB adjusted validation set
#wholeEB = "matrix", # store the EB adjusted whole set
#nonValidGenes = "character"  # store the genes which is removed in the adjustment.
#validationRatio
#		I forgot to handle 1.   For 0, means there is no validation set.  Only mat1Train/mat2Train will be assigned.   For 1, I think it should be prohibited because there is no training set there. I will never make this mistake by myself, but it is good to do exception handling.
#		It can go from 0 to 1, with specific meanings at 0, at 1, and in between. In between 0 and 1 means reserve that portion of the replicates for validation. (0.33 means 33% used for validation, 67% for training.)


# contains should be defined before representation
# for input dataframe, gene is arranged in row and sample is arranged in column
setClass("EBNplus",
	representation(
		DF1batch ="character",
		DF2batch ="character",
		mat1Train="matrix",
		mat2Train="matrix",
		mat1Test="matrix",
		mat2Test="matrix",
		mat1Validation = "matrix",
		mat2Validation = "matrix",
		batchWith0 = "character",
		correct0 = "logical", # 0 mean 0 in original set before log transform
		fixSet = "numeric",
		useRep = "logical",
		data4EB = "matrix",
		sampBatch = "data.frame",
		parList="list",
		trainEB ="matrix",
		testEB = "matrix",
		comEB = "matrix",
		validationEB = "matrix",
		wholeEB = "matrix",
		nonValidGenes = "character"
	),
	contains = "EBNPdata",
	prototype(batchWith0= "0", correct0=FALSE, fixSet= as.numeric(NA), useRep=TRUE)
)

setGeneric(name="getValidationSet", def=function(Object, ...) {standardGeneric("getValidationSet")})
setGeneric(name="getTestSet", def=function(Object, ...) {standardGeneric("getTestSet")})
setGeneric(name="divideSet", def=function(Object, ...) {standardGeneric("divideSet")})  # new version of getTrainTestSet
setGeneric(name="getTrainTestSet", def=function(Object, ...) {standardGeneric("getTrainTestSet")})
setGeneric(name="getData4EB", def=function(Object, ...) {standardGeneric("getData4EB")})
setGeneric(name="EBNplus", def=function(Object, ...) {standardGeneric("EBNplus")})
setGeneric(name="EBadj",def=function(Object, ...) {standardGeneric("EBadj")} )
setGeneric(name="train",def=function(Object, ...) {standardGeneric("train")} )
setGeneric(name="EBadjWithoutRep",def=function(Object, ...) {standardGeneric("EBadjWithoutRep")} )
setGeneric(name="adjustValidation",def=function(Object, ...) {standardGeneric("adjustValidation")} )

# Initialize function of the class
setMethod("initialize", "EBNplus", function(.Object, theData1, theData2, theColNameConvertFun, theColNameDuplicateFun, theRowNameConvertFun, theRowNameDuplicateFun)
{
	logDebug("before callNextMethod")
	.Object <- callNextMethod(.Object, theData1, theData2, theColNameConvertFun, theColNameDuplicateFun, theRowNameConvertFun, theRowNameDuplicateFun)
	logDebug("after callNextMethod")
	logDebug(paste("dim(mData1)=", paste(dim(.Object@mData1), collapse=" ", sep=" "), sep=""))
	logDebug(paste("dim(mData2)=", paste(dim(.Object@mData2), collapse=" ", sep=" "), sep=""))
	.Object
})

# get the validation set
setMethod("getValidationSet", "EBNplus", function(Object, validationRatio= 0.25 ,seed=NULL)
{
	logInfo("getValidationSet seed=", seed)
	set.seed(seed)
	numSamples <- ncol(Object@mat2Com)
	if(validationRatio !=0 )
	{
		logDebug(paste("validationRatio=", validationRatio, sep=""))
		logDebug(paste("numSamples=", numSamples, sep=""))
		valid.i <- sample(c(1:numSamples),floor(numSamples*validationRatio))
		#logDebug(paste("valid.i=", paste(valid.i, collapse=","), sep=""))
		Object@mat1Validation <- Object@mat1Com[ , valid.i]
		Object@mat2Validation <- Object@mat2Com[ , valid.i]
		Object@mat1Train <- Object@mat1Com[ , -valid.i]
		Object@mat2Train <- Object@mat2Com[ , -valid.i]
	}
	else
	{
		Object@mat1Train <- Object@mat1Com
		Object@mat2Train <- Object@mat2Com
	}
	Object
})

# get the test set
setMethod("getTestSet", "EBNplus", function(Object, testRatio= 1/3, theTestSeed=NULL )
{
  if (ncol(Object@mat1Train)==ncol(Object@mat2Train))
  {
    # training sets are the same size
    numSamples <- ncol(Object@mat2Train)
    if(testRatio!=0) {
      set.seed(theTestSeed)
      test.i <- sample(c(1:numSamples),floor(numSamples*testRatio))

      Object@mat1Test <- Object@mat1Train[ , test.i]
      Object@mat2Test <- Object@mat2Train[ , test.i]

      Object@mat1Train <- Object@mat1Train[ , -test.i]
      Object@mat2Train <- Object@mat2Train[ , -test.i]
    }
  }
  else
  {
    # training sets are different sizes due to pseudoreplicates
    numSamples1 <- ncol(Object@mat1Train)
    numSamples2 <- ncol(Object@mat2Train)
    if(testRatio!=0) {
      set.seed(theTestSeed)
      test.i1 <- sample(c(1:numSamples1),floor(numSamples1*testRatio))
      test.i2 <- sample(c(1:numSamples2),floor(numSamples2*testRatio))

      Object@mat1Test <- Object@mat1Train[ , test.i1]
      Object@mat2Test <- Object@mat2Train[ , test.i2]

      Object@mat1Train <- Object@mat1Train[ , -test.i1]
      Object@mat2Train <- Object@mat2Train[ , -test.i2]
    }
  }
  Object
})

# divide the data to subsets
# This method is used to replace getTrainTestSet
setMethod("divideSet", "EBNplus", function( Object, train=2, test=1, validation=1 )
{
  if ( validation !=0 )
  {
    validationRatio = validation/(train+test+ validation)
    Object = getValidationSet(Object, validationRatio=validationRatio)
  }
  if ( test!=0 )
  {
    testRatio  <- test/(train+test)
    Object = getTestSet (Object, testRatio)
  }
  Object
})


# get the train, test and validation set
# This one should be replaced by divideSet later
setMethod("getTrainTestSet", "EBNplus", function(Object, TrainRatio= c(2,1,1)) {

  numSamples <- ncol(Object@mat2Com)
  if(TrainRatio[3]!=0) {
    valid.i <- sample(c(1:numSamples),floor(numSamples*TrainRatio[3]/(sum(TrainRatio))))

    Object@mat2Validation <- Object@mat2Com[ , valid.i]
    Object@mat1Validation <- Object@mat1Com[ , valid.i]

    Object@mat2Train <- Object@mat2Com[ , -valid.i]
    Object@mat1Train <- Object@mat1Com[ , -valid.i]

    left.i <- c(1:numSamples)[-valid.i]
    train.i <- sample(left.i,floor(length(left.i)*TrainRatio[1]/(TrainRatio[1]+TrainRatio[2])))
    Object@mat2Train <- Object@mat2Com[ , train.i]
    Object@mat1Train <- Object@mat1Com[ , train.i]

    if (TrainRatio[2]!=0){

      Object@mat2Test <- Object@mat2Com[ ,-c(train.i,valid.i)]
      Object@mat1Test <- Object@mat1Com[ ,-c(train.i,valid.i)]
    }
  } else {
    train.i <- sample(c(1:numSamples),floor(numSamples*TrainRatio[1]/(TrainRatio[1]+TrainRatio[2])))
    Object@mat2Train <- Object@mat2Com[ , train.i]
    Object@mat1Train <- Object@mat1Com[ , train.i]
    Object@mat2Test <- Object@mat2Com[ ,-train.i]
    Object@mat1Test <- Object@mat1Com[ ,-train.i]
  }

  Object
})


# Merge the two train sets
# Change the original 0 value to NA if necessary
# The EB function require the data set to be merged
setMethod("getData4EB", "EBNplus", function(Object)
{
	dat <- NULL
	RNAseqMin <- NULL
	min.i <- NULL
	dat[min.i] <- NULL
	data4EB <- NULL
	if(Object@correct0)
	{
		if( ! Object@batchWith0 %in% c("1", "2", "both"))
		{
			logDebug("please tell me which set is fixed (usually RNAseq)")
		}
		else
		{
			if(Object@batchWith0 == "1")
			{
				dat = Object@mat1Train
				RNAseqMin = min(dat)
				min.i = which(dat ==RNAseqMin)
				dat[min.i] = NA
				data4EB  <- merge(dat, Object@mat2Train, by.x="row.names", by.y="row.names" )
			}
			if(Object@batchWith0 == "2")
			{
				dat = Object@mat2Train
				RNAseqMin = min(dat)
				min.i = which(dat ==RNAseqMin)
				dat[min.i] = NA
				data4EB  <- merge(Object@mat1Train, dat, by.x="row.names", by.y="row.names" )
			}
			if(Object@batchWith0 == "both")
			{
				dat1 = Object@mat1Train
				RNAseqMin = min(dat1)
				min.i = which(dat1 ==RNAseqMin)
				dat1[min.i] = NA
				dat2 = Object@mat2Train
				RNAseqMin = min(dat2)
				min.i = which(dat2 ==RNAseqMin)
				dat2[min.i] = NA
				data4EB  <- merge(dat1, dat2, by.x="row.names", by.y="row.names" )
			}
		}
	}
	else
	{
		data4EB  <- merge(Object@mat1Train, Object@mat2Train, by.x="row.names", by.y="row.names" )
	}
	# merge made data4EB a data.frame, turn back into matrix and fix names
	tmpNewRownames <- data4EB[,1]
	data4EB <- as.matrix(data4EB[-1])
	rownames(data4EB) <- tmpNewRownames
	logDebug("data4EB <- as.matrix")
	logDebug(paste("dim(data4EB)=", paste(dim(data4EB), sep=" ", collapse=" "), sep=""))
	printMatrix(data4EB)
	printElements(rownames(data4EB)[1:100])
	printElements(colnames(data4EB)[1:100])
	#data4EB  <- moveColumn2Rowname(data4EB)
	## data.matrix from data.frame converts character to factor to integer in R4+
	####Object@data4EB  <- data.matrix(data4EB, rownames.force = TRUE)
	Object@data4EB  <- data4EB
	logDebug("cbinds and rbinds")
	logDebug("Object@DF1batch=", Object@DF1batch)
	logDebug("Object@DF2batch=", Object@DF2batch)
	allColNames <- c(colnames(Object@mat1Train), colnames(Object@mat2Train))
	allBatches <- c(rep(Object@DF1batch, length(colnames(Object@mat1Train))), rep(Object@DF2batch, length(colnames(Object@mat2Train))))
	sampBatch <- data.frame(sample=allColNames, batch=allBatches)
	rownames(sampBatch) <- allColNames
	Object@sampBatch  <- sampBatch
	logDebug("row.names(sampBatch)")
	logDebug(paste(head(row.names(sampBatch), n=10), collapse=" "))
	logDebug("colnames(sampBatch)")
	logDebug(paste(head(colnames(sampBatch), n=10), collapse=" "))
	printMatrix(sampBatch)
	Object@sampBatch  <- sampBatch
	Object
})

# Next two functions make the design matrix (X) from the sample info file
build.design_plus <- function(vec, des=NULL, start=2)
{
	logDebug("in build.design_plus")
	tmp <- matrix(0,length(vec),nlevels(vec)-start+1)
	for (i in 1:ncol(tmp))
	{
		# TDC bug fixed
		# changed because otherwise alphabetical order reverses matrix entries
		#tmp[,i] <- vec==levels(vec)[i+start-1]
		tmp[,i] <- vec==unique(vec)[i+start-1]
	}
	logDebug("after build.design_plus loop")
	printMatrix(tmp)
	cbind(des,tmp)
}

design.mat_plus <- function(saminfo)
{
	logDebug("in design.mat_plus")
	tmp <- which(colnames(saminfo) == 'PBatch')
	tmp1 <- as.factor(saminfo[,tmp])

	design <- build.design_plus(tmp1,start=1)
	ncov <- ncol(as.matrix(saminfo[,-c(1:2,tmp)]))

	if(ncov>0)
	{
		for (j in 1:ncov)
		{
			tmp1 <- as.factor(as.matrix(saminfo[,-c(1:2,tmp)])[,j])
			design <- build.design_plus(tmp1,des=design)
		}
	}
	design
}

# Makes a list with elements pointing to which array belongs to which batch
# require the samples are arranged by batch, such as AAAABBBBB
list.batch_plus <- function(saminfo, theBatchList)
{
	# This is reversed between mbatch and original code
	logDebug("in list.batch_plus")
	#tmp1 <- as.factor(saminfo[,which(colnames(saminfo) == 'PBatch')])
	#printMatrix(tmp1)
	tmp1 <- as.vector(unlist(saminfo["PBatch"]))
	logDebug("list.batch_plus tmp1")
	printElements(tmp1)
	batches <- NULL
	for (i in 1:length(theBatchList))
	{
		logDebug("list.batch_plus uniTmp[i]")
		#print(theBatchList[i])
		# TDC bug fixed
		# changed this because otherwise, it depends on alphabetical sort order of batch ids provided
		#batches <- append(batches, list((1:length(tmp1))[tmp1==levels(tmp1)[i]]))
		batches <- append(batches, list((1:length(tmp1))[tmp1==theBatchList[i]]))
	}
	logDebug("list.batch_plus batches")
	printElements(batches)
	batches
}

# Following five functions find empirical hyper-prior values
# For parametric adjustment
aprior_plus <- function(gamma.hat)
{
  m=mean(gamma.hat, na.rm=TRUE); s2=var(gamma.hat, na.rm=TRUE); (2*s2+m^2)/s2
}

bprior_plus <- function(gamma.hat)
{
  m=mean(gamma.hat, na.rm=TRUE); s2=var(gamma.hat, na.rm=TRUE); (m*s2+m^3)/s2
}

postmean_plus <- function(g.hat,g.bar,n,d.star,t2)
{
  (t2*n*g.hat+d.star*g.bar)/(t2*n+d.star)
}

postvar_plus <- function(sum2,n,a,b)
{
  (.5*sum2+b)/(n/2+a-1)
}

it.sol_plus <- function(sdat,g.hat,d.hat,g.bar,t2,a,b,conv=.0001)
{
  n <- apply(!is.na(sdat),1,sum)
  g.old <- g.hat
  d.old <- d.hat
  change <- 1
  count <- 0

  while(change>conv)
  {
    g.new <- postmean_plus(g.hat,g.bar,n,d.old,t2)
    sum2 <- apply((sdat-g.new%*%t(rep(1,ncol(sdat))))^2, 1, sum, na.rm=TRUE)
    d.new <- postvar_plus(sum2,n,a,b)
    change <- max(abs(g.new-g.old)/g.old,abs(d.new-d.old)/d.old, na.rm=TRUE)
    g.old <- g.new
    d.old <- d.new
    count <- count+1
  }
  # "it.sol - This batch took", count, "iterations until convergence")
  adjust <- rbind(g.new, d.new)
  rownames(adjust) <- c("g.star","d.star")
  adjust
}

# Monte Carlo integration function to find the nonparametric adjustments
int.eprior_plus <- function(sdat,g.hat,d.hat)
{
  g.star <- d.star <- NULL
  r <- nrow(sdat)
  logDebug("calculating parameters with nonparametric method, it may take some time")
  for(i in 1:r)
  {
    g <- g.hat[-i]
    d <- d.hat[-i]
    x <- sdat[i,!is.na(sdat[i,])]
    n <- length(x)
    j <- numeric(n)+1
    dat <- matrix(as.numeric(x),length(g),n,byrow=TRUE)
    resid2 <- (dat-g)^2
    sum2 <- resid2%*%j
    LH <- 1/(2*pi*d)^(n/2)*exp(-sum2/(2*d))
    LH[LH=="NaN"]=0
    g.star <- c(g.star,sum(g*LH)/sum(LH))
    d.star <- c(d.star,sum(d*LH)/sum(LH))
    #if(i%%1000==0){#logDebug(i)}
  }
  adjust <- rbind(g.star,d.star)
  rownames(adjust) <- c("g.star","d.star")
  adjust
}

# fits the L/S model in the presence of missing data values
# X is design matrix
# y is the row of data
Beta.NA_plus = function(y,X)
{
  des=X[!is.na(y),]
  y1=y[!is.na(y)]
  if(is.null(dim(des))) {
    logDebug("There is no data in a row")
  }
  ## debug - for some data this give us system is exactly singular
  B <- solve(t(des)%*%des)%*%t(des)%*%y1
  return(B)
}

# Get stand data for emprical bayes
getStandData <- function(dat,stand.mean,var.pooled,n.array ) {
  stand.data <- (dat-stand.mean)/(sqrt(var.pooled)%*%t(rep(1,n.array)))
  return(stand.data)
}

# Get bayes adjusted data
getBayesData <- function(s.data, batches, batch.design,gamma.star,delta.star,n.batches, var.pooled, n.array, stand.mean) {

	logDebug("in getBayesData")
	logDebug(paste("dim(s.data)=", paste(dim(s.data), sep=" ", collapse=" "), sep=""))
	if(sum(dim(s.data))>0)
	{
		printMatrix(s.data)
	}
	logDebug(paste("dim(stand.mean)=", paste(dim(stand.mean), sep=" ", collapse=" "), sep=""))
	if(sum(dim(stand.mean))>0)
	{
		printMatrix(stand.mean)
	}

	bayesdata <- s.data
	j <- 1
	for (i in batches)
	{
		bayesdata[,i] <- (bayesdata[,i]-t(batch.design[i,]%*%gamma.star))/
						(sqrt(delta.star[j,])%*%t(rep(1,n.batches[j])))
		j <- j+1
	}

	logDebug(paste("dim(bayesdata)=", paste(dim(bayesdata), sep=" ", collapse=" "), sep=""))
	if(sum(dim(bayesdata))>0)
	{
		printMatrix(bayesdata)
	}

	bayesdata <- (bayesdata*(sqrt(var.pooled)%*%t(rep(1,n.array))))+stand.mean
	logDebug(paste("Second dim(bayesdata)=", paste(dim(bayesdata), sep=" ", collapse=" "), sep=""))
	if(sum(dim(bayesdata))>0)
	{
		printMatrix(bayesdata)
	}

	return(bayesdata)
}

plotPrior <- function(priorPlotsFile, gamma.hat,gamma.bar,t2, delta.hat, a.prior,b.prior)
{
	logDebug("plotPrior priorPlotsFile=", priorPlotsFile)
  CairoPNG(filename=priorPlotsFile, width = 1600, height = 1000, pointsize=24, bg = "transparent")
  on.exit(dev.off(), add = TRUE)
  par(mfrow=c(2,2))
  tmp <- density(gamma.hat[1,], na.rm =TRUE)
  plot(tmp,  type='l', main="Density Plot")
  xx <- seq(min(tmp$x), max(tmp$x), length=100)
  lines(xx,dnorm(xx,gamma.bar[1],sqrt(t2[1])), col=2)
  qqnorm(gamma.hat[1,])
  qqline(gamma.hat[1,], col=2)

  tmp <- density(delta.hat[1,], na.rm =TRUE)
  invgam <- 1/rgamma(ncol(delta.hat),a.prior[1],b.prior[1])
  if(length(invgam)==(sum(is.na(invgam))))
  {
    plot.new()
    mtext("INVGAM is all NaN or NA")
  }
  else
  {
    tmp1 <- density(invgam, na.rm =TRUE)
    plot(tmp,  typ='l', main="Density Plot", ylim=c(0,max(tmp$y,tmp1$y)))
    lines(tmp1, col=2)
    qqplot(delta.hat[1,], invgam, xlab="Sample Quantiles", ylab='Theoretical Quantiles')
    lines(c(0,max(invgam)),c(0,max(invgam)),col=2)
    title('Q-Q Plot')
  }
  #logDebug("finished prior plots")
}


# Generate EB parameters from train set
# will not output adjusted train set at the same time anymore
# called by train method
setMethod("EBNplus", "EBNplus", function(Object, par.prior=TRUE, minSampleNum=3, theEBNP_PriorPlotsFile=NULL)
{
	#TDC HERE trainEB
	logDebug("TDC HERE trainEB mbatch")
	logDebug("EBNplus args Obj")
	objectSummary(Object)
	logDebug("EBNplus args par.prior")
	#print(par.prior)
	logDebug("EBNplus args minSampleNum")
	#print(minSampleNum)
	logDebug("EBNplus theEBNP_PriorPlotsFile=", theEBNP_PriorPlotsFile)
	# Object@data4EB is a matrix which stores the value of all samples
	# the location of sample in the dat is defined by sampBatch and latter design
	dat  <- Object@data4EB
	saminfo  <- Object@sampBatch
	logDebug("dat")
	print(dim(dat))
	printMatrix(dat)
	logDebug("saminfo")
	printMatrix(saminfo)
	print(dim(saminfo))
	logDebug("check column and row names")
	stopifnotWithLogging("Data sample names should match and be in same order as those for batch data", all(colnames(dat)==rownames(saminfo)))
	colnames(saminfo)[2]="PBatch"

	stopifnotWithLogging("Array expression columns contain non-numeric values! (Check your data for non-numeric values)",(all(apply(dat,2,mode)=='numeric')))

	design <- design.mat_plus(saminfo)
	logDebug("design")
	printMatrix(design)
	logDebug("list.batch_plus(saminfo)")
	batches <- list.batch_plus(saminfo, c(Object@DF1batch, Object@DF2batch))
	logDebug("after list.batch_plus(saminfo)")
	#print(batches)
  n.batch <- length(batches)  # the number of batches, n.batches is the sample number in every batches

  ######check number of batch
  if(n.batch==1)
  {
    logWarn('There is only ONE batch, no adjustment made.')
    return(dat)
  }
  n.batches <- sapply(batches, length) # the sample number in every batches
  n.array <- sum(n.batches)  # the sum of sample numbers from all batches
  logDebug("n.batches")
  #print(n.batches)
  logDebug("n.array")
  #print(n.array)

  ### Check for missing values
  # missing values include two parts: original one is NA, original one in 0
  NAs = any(is.na(dat))
  if(NAs)
  {
    # logDebug(paste('Found',sum(is.na(dat)),'Missing Data Values',sep=' '))
  }

  ##Check for genes with whole batch missing or no variation.
  gene.var<-apply(dat, 1, var, na.rm=TRUE)
  VAR0<-any(gene.var==0)
  #TDC-PRESERVE-NAs
  if(NAs | VAR0)
  {

    missbatch<-apply(!is.na(dat), 1, function(x) tapply(x, INDEX=factor(saminfo[,'PBatch']), FUN=sum) )
    logDebug("missbatch matrix")
    printMatrix(missbatch)

    remove.gene.ind<-which(colSums(missbatch<minSampleNum)!=0 | gene.var==0)
    if(length(remove.gene.ind)>0)
    {
      remove.gene<-dat[remove.gene.ind,,drop=FALSE]
      Original.dat = dat
      dat<-Original.dat[-remove.gene.ind,]
      logDebug("There are ", length(remove.gene.ind)  ," genes that were removed because of whole batch missing, no variation or all zero in original data" )
    }
  }

  ###Standardize Data across genes
  # B.hat is a matrix, column is gene, row is batches
  B.hat <- NULL
  if (!NAs)
  {
    # 'sd inside !NAs'
    B.hat <- solve(t(design)%*%design)%*%t(design)%*%t(as.matrix(dat))
  } else {
    ### DEBUG this isn't generating an array/matrix/dataframe, but a list
    # when there is NA in data, use Beta.NA to treat the data
    B.hat <- apply(dat,1,Beta.NA_plus,design)
  }
  logDebug("B.hat")
  printMatrix(B.hat)

  ###Standarization Model
  # this acutally, in this case calculated the mean of B.hat of each entry with sample number of batch as weight
  # grand.mean is a vector
  if (is.na(Object@fixSet)) {
    grand.mean <- t(n.batches/n.array)%*%B.hat[1:n.batch,]
  } else {
    stopifnotWithLogging("Fix set should be less than or equal to n.batch", Object@fixSet <= n.batch)
    grand.mean  <- t(as.matrix(B.hat[Object@fixSet, ]))  # keep the mean of the fixedSet
  }
  logDebug("grand.mean")
  printMatrix(grand.mean)

  # calculate the variation of each genes in each batches
  if (!NAs)
  {
    var.pooled <- ((dat-t(design%*%B.hat))^2)%*%rep(1/n.array,n.array)
  }
  else
  {
    var.pooled <- apply(dat-t(design%*%B.hat),1,var,na.rm=TRUE)
  }
  logDebug("var.pooled")
  printElements(var.pooled)

  # get stand.mean
  # Just extand the grand.mean to every sample
  stand.mean <- t(grand.mean)%*%t(rep(1,n.array))
  logDebug("stand.mean 1")
  printMatrix(stand.mean)

  if(!is.null(design))
  {
    tmp <- design
    tmp[,c(1:n.batch)] <- 0
    # this make the stand.mean not changed
    stand.mean <- stand.mean+t(tmp%*%B.hat)
  }
  logDebug("stand.mean 2")
  printMatrix(stand.mean)

  # The standardized data in the fomula
  s.data <- (dat-stand.mean)/(sqrt(var.pooled)%*%t(rep(1,n.array)))
  logDebug("s.data")
  printMatrix(s.data)

  ##Get regression batch effect parameters
  batch.design <- design[,1:n.batch]
  if (!NAs)
  {
    gamma.hat <- solve(t(batch.design)%*%batch.design)%*%t(batch.design)%*%t(as.matrix(s.data))
  }
  else
  {
    gamma.hat=apply(s.data,1,Beta.NA_plus,batch.design)
  }
  logDebug("gamma.hat")
  printMatrix(gamma.hat)

  delta.hat <- NULL
  for (i in batches)
  {

    #To make sure no NA generated for delta.hat
    delta.hat.i<-apply(s.data[,i, drop=FALSE], 1, var,na.rm=TRUE)
    if(!all(is.na(delta.hat.i)))
    {
      delta.hat.i[is.na(delta.hat.i)]<-mean(delta.hat.i, na.rm=T)
    }
    delta.hat <- rbind(delta.hat, delta.hat.i)
  }
  #set priors for batches with only 1 sample.
  delta.hat[is.na(delta.hat[,1]),]<-apply(delta.hat,2, mean, na.rm=TRUE)
  ###Find Priors
  gamma.bar <- apply(gamma.hat, 1, mean, na.rm=TRUE)
  t2 <- apply(gamma.hat, 1, var, na.rm=TRUE)
  a.prior <- apply(delta.hat, 1, aprior_plus)
  b.prior <- apply(delta.hat, 1, bprior_plus)

  ###Plot empirical and parametric priors
  if (!is.null(theEBNP_PriorPlotsFile) & par.prior)
  {
  	logDebug("plot priors")
    plotPrior(theEBNP_PriorPlotsFile, gamma.hat,gamma.bar,t2, delta.hat, a.prior,b.prior)
  }
  ###Find EB batch adjustments
  gamma.star <- NULL
  delta.star <- NULL
  if(par.prior)
  {
    # Finding parametric adjustments
    for (i in 1:n.batch)
    {
			logDebug("parametric adjustments")
      temp <- it.sol_plus(s.data[,batches[[i]], drop=FALSE],gamma.hat[i,],delta.hat[i,],gamma.bar[i],t2[i],a.prior[i],b.prior[i])
      gamma.star <- rbind(gamma.star,temp[1,])
      delta.star <- rbind(delta.star,temp[2,])
    }
  }
  else
  {
    # Finding nonparametric adjustments
    for (i in 1:n.batch)
    {
		logDebug("nonparametric adjustments")
      temp <- int.eprior_plus(as.matrix(s.data[,batches[[i]]]),gamma.hat[i,],delta.hat[i,])
      gamma.star <- rbind(gamma.star,temp[1,])
      delta.star <- rbind(delta.star,temp[2,])
    }

  }

  # get the EB adjusted train Data ###
  bayesdata = getBayesData(s.data, batches, batch.design,gamma.star,delta.star,n.batches, var.pooled, n.array, stand.mean)

  ###add back the removed genes with missing data in whole batch
  #TDC-PRESERVE-NAs
  resultsDat <- NULL
  if(exists('Original.dat'))
  {
  	logDebug("keep the dim of Original.dat, keep the gene with all NA")
    resultsDat <- get('Original.dat')
    resultsDat[-remove.gene.ind,]<-bayesdata  # keep the dim of Original.dat, keep the gene with all NA
  }
  else
  {
  	logDebug("new 'original.data' actually bayesdata")
    resultsDat<-bayesdata
  }
  logDebug("resultsDat")
  #print(resultsDat)

  # #checkMatrix(stand.mean)
  Object@parList <- list(s.data = s.data, var.pooled = var.pooled, grand.mean=grand.mean, stand.mean=stand.mean, B.hat= B.hat, batch.design=batch.design, gamma.star = gamma.star, delta.star=delta.star, n.batches=n.batches, n.array=n.array, batches=batches)
  Object@trainEB  <- resultsDat  # train.EB may not be the final version of train set adjusted by this algorithm

  return(Object)
})


# adjust the appointed dataset with parameters from EB
# This method doesn't call EB, it is used after EB method
# Now this is for two batches
setMethod("EBadj", "EBNplus", function(Object,set)
{
	mat1 <- NULL
	mat2 <- NULL
	switch(set,
		train=
		{
			logDebug("train")
			mat1  <- Object@mat1Train
			mat2  <- Object@mat2Train
		},
		test=
		{
			logDebug("test")
			mat1  <- Object@mat1Test
			mat2  <- Object@mat2Test
		},
		validation=
		{
			logDebug("validation")
			mat1  <- Object@mat1Validation
			mat2  <- Object@mat2Validation
			colnames(mat1) <- paste(colnames(mat1),Object@DF1batch,sep=".")
			colnames(mat2) <- paste(colnames(mat2),Object@DF2batch,sep=".")
		},
		com=
		{
			logDebug("com")
			mat1  <- Object@mat1com
			mat2  <- Object@mat2com
			colnames(mat1) <- paste(colnames(mat1),Object@DF1batch,sep=".")
			colnames(mat2) <- paste(colnames(mat2),Object@DF2batch,sep=".")
		},
		whole=
		{
			logDebug("whole")
		  ## data.matrix from data.frame converts character to factor to integer in R4+
			#mat1  <- data.matrix(moveColumn2Rowname(Object@DF1))
		  ## data.matrix from data.frame converts character to factor to integer in R4+
			#mat2  <- data.matrix(moveColumn2Rowname(Object@DF2))
			mat1  <- Object@mData1
			mat2  <- Object@mData2
			colnames(mat1) <- paste(colnames(mat1),Object@DF1batch,sep=".")
			colnames(mat2) <- paste(colnames(mat2),Object@DF2batch,sep=".")
		}
	)

	logDebug(paste("dim(mat1)=", paste(dim(mat1), sep=" ", collapse=" "), sep=""))
	if(sum(dim(mat1))>0)
	{
		printMatrix(mat1)
		logDebug("dim(mat1)=")
	}
	logDebug(paste("dim(mat2)=", paste(dim(mat2), sep=" ", collapse=" "), sep=""))
	if(sum(dim(mat2))>0)
	{
		printMatrix(mat2)
		logDebug("dim(mat2)=")
	}

	dat <- merge(mat1,mat2, by.x="row.names", by.y="row.names", sort=TRUE)
	#dat <- moveColumn2Rowname(dat)
	# merge made dat a data.frame, turn back into matrix and fix names
	tmpNewRownames <- dat[,1]
	dat <- as.matrix(dat[-1])
	rownames(dat) <- tmpNewRownames

	logDebug(paste("dim(dat)=", paste(dim(dat), sep=" ", collapse=" "), sep=""))
	if(sum(dim(dat))>0)
	{
		printMatrix(dat)
		logDebug("dim(dat)=")
	}

	parList <- Object@parList
	#message("MBatch parList")
	printElements(parList)
	#message("MBatch Object@trainEB")
	printMatrix(Object@trainEB)
	if (nrow(dat) == nrow(Object@trainEB))
	{
		orderyOnx <- order(match(rownames(dat),row.names(Object@trainEB)))  #gene sequence is same as parameters
		dat <- dat[orderyOnx, ]
		#dat <- data.matrix(dat)    # can't use as.matrix, it will change the number to character
	}
	else
	{
		logDebug("There are some genes that can not be adjusted by parameters from this algorithm")
	}

	logDebug("after parlist")
	logDebug(paste("dim(dat)=", paste(dim(dat), sep=" ", collapse=" "), sep=""))
	if(sum(dim(dat))>0)
	{
		printMatrix(dat)
	}

  n.array <- ncol(dat)
  if (nrow(parList$stand.mean) < nrow(dat))
  {
    #TDC-PRESERVE-NAs
	  valid.genes <- row.names(parList$stand.mean)
	  logDebug("valid.genes")
	  #print(valid.genes)
    nonValidGenes = row.names(dat)[!row.names(dat) %in% valid.genes]
    logDebug("nonValidGenes")
    #print(nonValidGenes)
    datNonValid = dat[nonValidGenes, ]
	  dat <- dat[valid.genes, ]
    logDebug("Non-valid genes were removed before adjustment")
  }

	logDebug("after Non-valid")
	logDebug(paste("dim(dat)=", paste(dim(dat), sep=" ", collapse=" "), sep=""))
	if(sum(dim(dat))>0)
	{
		printMatrix(dat)
	}

  stand.mean <- matrix(rep(parList$stand.mean[,1],n.array), ncol=n.array, byrow=FALSE)
  # #checkMatrix(stand.mean)
  stand.data <- getStandData(dat,stand.mean,parList$var.pooled, n.array)  # if want to order parList$var.pooled, should order by its name

	logDebug("after getStandData")
	logDebug(paste("dim(stand.data)=", paste(dim(stand.data), sep=" ", collapse=" "), sep=""))
	if(sum(dim(stand.data))>0)
	{
		printMatrix(stand.data)
	}

  batches <- list(c(1:ncol(mat1)), c((1+ncol(mat1)):(ncol(mat1)+ncol(mat2))))

	logDebug("batches")
	printElements(batches)

	batch.design <- rbind(matrix(rep(c(1,0),ncol(mat1)), ncol=2, byrow=T), matrix(rep(c(0,1),ncol(mat2)),ncol=2, byrow=T))

	logDebug("after batch.design")
	logDebug(paste("dim(batch.design)=", paste(dim(batch.design), sep=" ", collapse=" "), sep=""))
	if(sum(dim(batch.design))>0)
	{
		printElements(batch.design)
	}

  n.batches=c(ncol(mat1), ncol(mat2))
	logDebug("n.batches")
	printElements(n.batches)

	# parList$gamma.star INCORRECT
	bayesData <- getBayesData(stand.data, batches, batch.design, parList$gamma.star,
	# parList$delta.star INCORRECT
					parList$delta.star, n.batches, parList$var.pooled, n.array, stand.mean)

	logDebug("after bayesData")
	logDebug(paste("dim(bayesData)=", paste(dim(bayesData), sep=" ", collapse=" "), sep=""))
	if(sum(dim(bayesData))>0)
	{
		printMatrix(bayesData)
	}

  # keep the fixSet without any adjustment
  if (!is.na(Object@fixSet)) {
    if(Object@fixSet==1) {
      bayesData = cbind(mat1[row.names(dat), ], bayesData[ row.names(dat),-c(1:ncol(mat1))])
    }
    if(Object@fixSet==2) {
      bayesData = cbind(bayesData[row.names(dat), c(1:ncol(mat1))], mat2[row.names(dat), ])
    }
  }

	#TDC-PRESERVE-NAs
	if(exists('datNonValid'))
	{
	  logDebug("EBadj datNonValid")
	  datNonValid <- get('datNonValid')
	  nonValidGenes <- get('nonValidGenes')
	  tmp <- rbind(bayesData, datNonValid)
	  rownames(tmp) <- c(rownames(bayesData), nonValidGenes)
	  bayesData <- tmp
	}
	logDebug("EBadj EBadj after non valid")
	#print(bayesData)

  switch(set,
    train= {
      Object@trainEB <- bayesData
    },
    test={
      Object@testEB <- bayesData
    },
    validation={
      Object@validationEB <- bayesData
    },
    com={
      Object@comEB <- bayesData
    },
    whole={
      Object@wholeEB <- bayesData
    }
  )
  return(Object)
})


# train the sample
# the train function doesn't random split samples
# should assign train set to object before using train function
# if test is not empty, will return a merged adjusted test set
setMethod("train", "EBNplus", function(Object, par.prior=TRUE, test=FALSE, minSampleNum=3, theEBNP_PriorPlotsFile=NULL)
{
	logDebug("inside train")
	logDebug("train theEBNP_PriorPlotsFile=", theEBNP_PriorPlotsFile)
	# renames the two trainsets for Emprical study
	colnames(Object@mat1Train) <- paste(colnames(Object@mat1Train),Object@DF1batch,sep=".")
	colnames(Object@mat2Train) <- paste(colnames(Object@mat2Train),Object@DF2batch,sep=".")
	logDebug(paste("colnames(Object@mat1Train)=", paste(colnames(Object@mat1Train)[1:3], sep=" ", collapse=" "), sep=""))
	printMatrix(Object@mat1Train)
	logDebug(paste("colnames(Object@mat2Train)=", paste(colnames(Object@mat2Train)[1:3], sep=" ", collapse=" "), sep=""))
	printMatrix(Object@mat2Train)

	logDebug("inside train, call getData4EB")
	objectSummary(Object)
	Object  <- getData4EB(Object)  # only use train data
	logDebug("inside train, after getData4EB")
	objectSummary(Object)
	# #checkMatrix(Object@data4EB)

	logDebug("call EB MBatch")
	Object  <- EBNplus(Object, par.prior=par.prior, minSampleNum=minSampleNum, theEBNP_PriorPlotsFile=theEBNP_PriorPlotsFile)
	logDebug("after EB MBatch")
	objectSummary(Object)

	if(test == TRUE)
	{
		logDebug("inside TEST branch MBatch")
		# renames the test sets
		colnames(Object@mat2Test) <- paste(colnames(Object@mat2Test),Object@DF2batch,sep=".")
		colnames(Object@mat1Test) <- paste(colnames(Object@mat1Test), Object@DF1batch,sep=".")
		Object<- EBadj(Object,"test")
		logDebug("Check the adjusted test set")
		printMatrix(Object@testEB)
	}
	return(Object)
})


# Adjust the two dataset without replicates
setMethod("EBadjWithoutRep", "EBNplus", function(Object, par.prior=TRUE, minSampleNum=3) {
  Object@useRep = FALSE

  # Get data set with same genes but keep all the samples
  ##dataCom = getCom(Object, by = "row", byRow.x=1,byRow.y=1 )
  dataCom <- makeCommonRows(Object)
  ## data.matrix from data.frame converts character to factor to integer in R4+
  #Object@mat1Train = data.matrix(moveColumn2Rowname(dataCom@DF1))
  ## data.matrix from data.frame converts character to factor to integer in R4+
  #Object@mat2Train = data.matrix(moveColumn2Rowname(dataCom@DF2))
  Object@mat1Train = dataCom@DF1
  Object@mat2Train = dataCom@DF2

  Object  <- getData4EB(Object)
  Object  <- EBNplus(Object, par.prior=par.prior, minSampleNum=minSampleNum)
  Object = EBadj(Object, "whole")
  return(Object)

})

# fixset is NA or set number
setMethod("adjustValidation", "EBNplus", function(Object, par.prior=TRUE, minSampleNum=3)
{
	logDebug("adjustValidation call train")
	objafterEB  <- train(Object,par.prior=par.prior, test=FALSE, minSampleNum=minSampleNum)
	logDebug("adjustValidation call EBadj")
	objafterEB <- EBadj(objafterEB ,"validation")
	logDebug("adjustValidation get return value")
	validationEB <- objafterEB@validationEB
	return(validationEB)
})

